# Пример реализации архитектуры

Проект для демонстрации базовой архитектуры приложения. Правильной архитектуры не бывает, бывает только подходящая. Это один из вариантов, в котором используется CQRS, DDD, что-то из гексагональной и чистой архитектуры.

## Запуск проекта
* `docker network create docker_default` - создать сеть, если ее нет (нужна для доступа других сервисов, например, Kafka)
* `docker-compose up -d --build` - собрать и запустить сервисы в Docker
* `docker exec -it app /bin/bash` - зайти в контейнер app
* `composer install` - установить пакеты

После этого проект должен быть в рабочем состоянии. Дополнительно реализованные команды:

* `composer tests` - опционально прогнать тесты
* `composer cs-fix` - опционально прогнать cs-fixer
* `bin/console app:create-product new_uniq_alias2` - создать первый товар с кодом `new_uniq_alias2`
* `bin/console app:set-price new_uniq_alias2 100` - установить цену 100 для товара с кодом `new_uniq_alias2`

После создания товара он станет доступен по адресу [http://localhost/products/new_uniq_alias2](http://localhost/products/new_uniq_alias2)

## Основные слои
![Схема в miro](https://miro.com/api/v1/boards/uXjVPIMKBOE=/picture?etag=R3458764514381778360_1&size=420)

[Схема в miro](https://miro.com/app/board/uXjVPIMKBOE=/?share_link_id=482410903178).

Директория `src/Product` - пример реализации ограниченного контекста **Product**.
* **Domain** - предметная область, описание бизнес-правил и их взаимодействие между собой. Не зависит и не должно зависеть ни от каких других слоев приложения. Является отражением какой-то бизнес-сущности, бизнес-процесса.
  * **Entity** - описание сущностей, анемичная модель, объекты не должны содержать бизнес-логику, но могут содержать сеттеры/геттеры, логику взаимодействия и зависимости. Обычно сущность одна.
  * **Repository** - абстрактная реализация взаимодействия со слоем данных, тоже самое, что Gateway. Конкретная реализация должна быть в слое инфраструктуры. Репозиторий одной предметной области может быть реализован через несколько интерфейсов (ISP).
  * **Event** - доменные события, триггерятся при изменении объектов домена через сервисный слой
  * **Exception** - исключения при работе с предметной областью, ошибки
  * **Service** - действия с сущностями и Value Object, которые не относятся напрямую к каким-либо сущностями; действия в контексте предметной области. не относящиеся ни к одной сущности;
  * **ValueObject** - атомарные элементы предметной области, не имеющие идентификтора, но значение объекта делает уникальным. Например, составной адрес (индекс + город + улица + дом + квартира) или координаты (широта + долгота). Данные объекты не могут существовать самостоятельно, они всегда являются частью сущности.
  * **Enum** - перечисления и списки, может использоваться как набор допустимых значений в сущностях и value object.
  * **Bus** - абстрактная реализация шины обмена данными (в Shared)
* **Application** - слой приложения, основной функционал, зависимый от домена, оперирует сущностями, их взаимодействием, событиями. Зависит от домена.
  * **Command** - Команды в CQRS, могут что-то делать, но не возвращают объект изменения, могут возвращать идентификатор объекта
    * **SetPrice** - пример команды установки цены для конкретного товара
      * **SetPriceCommand.php** - команда, в ней должны быть описаны зависимости команды и геттеры данных для хэндлера
      * **SetPriceHandler.php** - хэндлер команды. В конструкторе указываются зависимости. В методе `__invoke()` в качестве аргумента указывается реализуемая команда, в самом методе реализуется обработка данных.
  * **Request** - Запросы в CQRS, могут только получить что-то, но ничего не делают, возвращают запрошенные объекты
  * **Subscriber** - Подписчики на события домена и системы
* **Infrastructure** - (вторичные) адаптеры для работы приложения с какой-то внешней технологией, конкретные реализации
  * **Repository** - пример реализации взаимодействия с БД. 
  * **Bus** - пример реализации шин данных (находится в Shared)
  * В случае замены одной технологии на другую просто реализуется другое взаимодействие на этом уровне (адаптеры для разных СУБД, например). 
  * Для приложения все адаптеры внутри инфраструктуры должны быть взаимозаменяемыми, что реализовано через интерфейс в Domain/Repository. 
  * Другие примеры инфраструктуры: кеширование, поисковые механизмы, очереди, взаимодействие с внешими службами, отправка почты или sms.
* **Port** - тоже самое, что и (первичные) адаптеры, UI и т.д. Внешний слой, взаимодействует с внешним миром, используется для ввода и вывода, команд и возврата результата. Вся система получает запросы и отдает результат в этом слое. В данном разделе будут конкретные реализации взаимодействия, например, через консоль, HTTP-запросы, grpc, soap, консьюмеры очередей, что угодно.
  * **Console** - консольные команды и всё, что с ними связано
  * **Http** - взимодействие с веб и всё, что с этим связано

Директория `src/Shared` используется для общих переиспользуемых компонентов, для нее применяются те же правила разделения на слои, что и для предметной области
* **Domain**
  * **Aggregate** - корневой агрегат, от которого должны наследоваться сущности. Может содержать общую логику для всех сущностей
* **Infrastructure** - тоже самое, что и в контексте
  * **Bus** - конкретная реализация шины, используемой в контекстах

## Модель данных, Предметная область, Entity, ограниченный контекст
Описание предметной области осуществляется в виде модели или сущности (Entity). 
Используется анемичная модель, то есть не должна содержать бизнес-логики, кроме геттеров/сеттеров и зависимостей.
Взаимодействие между моделями происходит посредством сервисов, они могут содержать бизнес-логику, кроме того они триггерят события домена.
Хорошее [описание](https://thevaluable.dev/anemic-domain-model/) разницы между анемичной и богатой моделью.

## Агрегат и корень агрегата
Агрегатом называется набор сущностей (обычно одна сущность) и объектов-значение (Value Object), ограниченных контекстом (Boundary Context). Корнем агрегата является одна единственная сущность, наиболее значимая и ответственная в рамках одного контекста, все остальные сущности являются вторичными. Взаимодействие между контекстами происходит только через корневой агрегат. Например, в контексте товара корнем агрегата может быть сущность Product, но в агрегат также может входить цена товара Price, которая является Value Object, состоящим из числа и валюты. Извне, например, из контекста оформления заказа Checkout, доступ к цене товара может происходить только через запрос вида `$product->getPrice()`.

## Value Object
Часть сущности, не имеющая идентификатора, но значение (набор значений атрибутов) которой само по себе является значением. Может состоять из других Value Object и примитивов. Может переиспользоваться в рамках контекста. Пример value object - координаты в виде пары значений долготы и широты. Не может содержать сущности и какую-либо бизнес-логику, кроме проверки допустимости значений. При нарушении валидности значений должен выкидывать исключение, например, "цена не может быть отрицательной".

## Domain Events
События домена - это массив событий, описывающих историю изменения сущности в рамках одного запросы или команды. Разработчик сам определяет, какие события каких сущностей необходимо фиксировать, значимые для приложения. События формируются в сервисном слое домена, в события попадают значимые данные. Дальнейшая обработка событий может производиться подписчиками, на каждое событие может быть несколько подписчиков.

## Слой данных
Хранилище данных - это часть инфраструктуры, а значит деталь реализации. Модель данных и бизнес-логика должны быть отделены от конкретных реализаций и технологий. При использовании Doctrine необходимо использовать [mapping](https://www.doctrine-project.org/projects/doctrine-mongodb-odm/en/2.3/reference/xml-mapping.html) через XML файлы, описывающие поля, индексы и связи. Нельзя прописывать атрибуты для работы с Doctrine в сущностях. Пример реализации `src/Product/Infrastructure/Repository/ODM/Entity.Product.mongodb.xml`

## Data Flow
* Запрос поступает на один из портов, например, в Http/Controller
* Порт запрашивает шину в зависимости от необходимых действий, это можеть быть только либо запрос, либо команда
  * Запрос реализует только операцию чтения (R из CRUD), получить какой-то объект, не изменяя его или другие данные
  * Команда реализует любые действия над объектом (CUD из CRUD), но не вернуть его
  * И запрос и команда представляют собой класс-конверт для шины (Envelope в терминологии messenger)
* Класс-конверт определяет в конструкторе какие данные он может принять для отправки по шине, пример реализации в `src/Product/Application/Request/FindProduct/FindProductQuery.php`
  * Также класс-конверт может инкапсулировать логику получения этих данных для обработки
* Хэндлеры - это обработчики содержимого конвертов (данных запроса или команды), они привязываются к конкретным классам-конвертам и конкретным шинам. Пример - `src/Product/Application/Request/FindProduct/FindProductQueryHandler.php`. По сути является Use Case в терминологии Чистой Архитектуры.
  * Через конструктор реализуются зависимости, например, репозиторий.
  * В методе `__invoke()` реализуется логика обработки сообщения, это и есть логика приложения, поэтому команды и запросы находятся в Application.
  * Хэндлеры могут выбрасывать исключения, например, если товар не найден - `ProductNotFoundException`
  * В случае запросов хэндлер может вернуть ответ - используется интерфейс `ResponseInterface`
* Порт (?) должен перехватить исключения, выброшенные в процессе обработки сообщения в шине и выдать соответствующий результат (404-ый или 500-ответ, записать логи и т.д.)
* Ответ может быть возвращен пользователю в нужном виде (json, html, сообщение в консоли, сообщение в очередь и т.д.)

## Presenters
На данный момент не реализовано. Может быть дополнительный слой над контроллером, который отвечает за представление данных, полученных от хэндлера. На данный момент этот слой реализуется привязкой к фреймворку, поэтому должен быть в слое инфраструктуры.

## Event Sourcing (ES)
События изменения состояния (сущности, агрегата) должны фиксироваться в виде отдельных событий и в той же последовательности. Пример - изменилась цена товара, это событие, содержащее в себе товар и цену. События могут происходить как до, так и после изменения состояния. Например, мы можем создать события "prePriceSet" и "postPriceSet", в первом будет фиксироваться состояние товара до изменения, а во втором после изменения. Какие возможности предоставляет ES:
* Разделение ответственности (SIP) - команда выполняет только изменение состояния агрегата, что вызывает определенное событие. Все остальные действия могут выполняться обработчиками (подписчиками) событий. Пример - мы изменили цену товара командой, а отправка уведомления об изменении цены происходит уже в обработчике события.
* Контроль исполнения - обработчики события могут прерывать или корректировать работу приложения
* История изменений состояния приложения в процессе работы, возможность откатить изменения или узнать состояние агрегата на каком-то этапе обработки

В рамках проекта реализация ES выполнена на основе компонента [symfony/event-dispatcher](https://symfony.com/doc/current/components/event_dispatcher.html). 

#  Работа с Apache Kafka

Для работы с Apache Kafka реализован свой транспорт на базе symfony/messenger в виде Symfony Bundle [vitalyoborin/symfony-kafka-transport](https://packagist.org/packages/vitalyoborin/symfony-kafka-transport). Каждый транспорт подключается к отдельному топику, на каждый транспорт/топик вешается один хэндлер. Запуск консьюмеров командой `bin/console messenger:consume kafka.products kafka.prices -vv`, пример сообщения для установки цены товара в топике prices:

`{"price": 123,"currency": "USD"}`

в качестве ключа сообщения используется значение alias товара, например, `new_uniq_alias2`

Пока работает отправка и получение сообщений из топиков, но нет разделения транспортов на отдельные топики, подписки на отдельные топики.
